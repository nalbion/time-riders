# Time Riders Development Guidelines

This document provides comprehensive guidelines for developing the Time Riders Unity project. It serves as a reference for all team members and AI assistants (GitHub Copilot, Cursor AI, etc.) to ensure consistency and quality.

## Project Philosophy

Time Riders is designed to:
1. Provide engaging physics-based bike racing gameplay
2. Demonstrate good software engineering practices
3. Be accessible to beginners while showing professional code structure
4. Create a fun, challenging racing experience across varied terrain types

## Coding Standards

### Architecture

- **Component-Based Design**: Use Unity's component system effectively
- **SOLID Principles**: Apply all five SOLID principles in code design
- **Separation of Concerns**: Each class has one clear responsibility
- **Dependency Injection**: Use constructor or property injection for dependencies
- **Manager Systems**: Use manager classes sparingly and with clear responsibility

### Code Organization

- **Namespaces**: Use `TimeRiders` namespace with appropriate sub-namespaces
- **File Structure**: One class per file (with exceptions for small utility classes)
- Only create interfaces when you expect multiple implementations (YAGNI principle)
- Avoid unnecessary interfaces that add maintenance burden
- Use dependency injection to decouple systems when appropriate
- Public methods at the top of files, private helpers at the bottom
- **Encapsulation**: Keep fields private unless explicitly needed externally

### Naming Conventions

- **Descriptive Names**: Self-documenting code with clear variable/method names
- **Consistency**: Follow C# standard naming conventions
- **No Abbreviations**: Use full words except for widely understood abbreviations
- **Hungarian Notation**: Avoid prefixes like `m_` or `_` for member variables

## Unity-Specific Guidelines

### Inspector Organization

- **Headers**: Group related fields with `[Header("Group Name")]`
- **Tooltips**: Add `[Tooltip("Description")]` to explain non-obvious fields
- **Serialization**: Use `[SerializeField]` for private fields that need Inspector exposure
- **Proper Types**: Use appropriate types (e.g., `LayerMask` for layers)

### Performance Considerations

- **Caching**: Cache component references in `Awake()`
- **Physics**: Use `FixedUpdate()` for physics operations
- **Garbage Collection**: Minimize allocations in frequent update methods
- **Optimized Loops**: Be mindful of performance in loops and LINQ queries
- **Object Pooling**: Use pooling for frequently created/destroyed objects

### Assets Management

- **Prefabs**: Use prefabs for reusable objects
- **Scenes**: Keep scenes organized with empty GameObjects as containers
- **Scriptable Objects**: Use for configuration data and shared resources

## Documentation Guidelines

### Code Documentation

- **Class Headers**: Every class should have a summary comment
- **Public APIs**: All public methods need XML documentation
- **Complex Logic**: Add explanatory comments for non-obvious algorithms
- **TODOs**: Mark incomplete work with `// TODO: description`

### Project Documentation

- **README**: Maintain up-to-date project overview
- **Design Documents**: Document major systems and their interactions
- **Tutorials**: Include examples for key features

## Testing Approach

### Unit Testing

- **Test Coverage**: Focus on core game logic and critical systems
- **Isolation**: Test classes in isolation with mocked dependencies
- **Naming**: Use descriptive test names that explain the test scenario

### Play Testing

- **Performance Testing**: Regular profiling to identify bottlenecks
- **Edge Cases**: Test unusual player behaviors and extreme scenarios
- **Platform Testing**: Verify functionality across target platforms

## New Features and Systems

When implementing new features:

1. **Plan First**: Document the feature's purpose and implementation approach
2. **Interface Design**: Define clear interfaces before implementation
3. **Incremental Development**: Build features in small, testable increments
4. **Code Review**: Have code reviewed before merging

## Bug Fixing Process

1. **Reproduce**: Ensure the bug is consistently reproducible
2. **Isolate**: Identify the root cause
3. **Fix**: Implement minimal changes to address the issue
4. **Test**: Verify the fix and check for regressions
5. **Document**: Note the fix and any relevant information

## Specific System Guidelines

### Bike Physics

- **Realistic Feel**: Focus on fun over perfect simulation
- **Terrain Adaptation**: Bikes should respond differently to terrain types
- **Control Responsiveness**: Ensure controls feel tight and responsive
- **Stability**: Implement stability systems that feel natural

### AI Agents

- **Clear Behavior**: AI should have understandable, predictable behavior
- **Difficulty Levels**: Scale AI difficulty appropriately
- **Performance**: Optimize AI logic for minimal performance impact
- **Emergent Behavior**: Create interesting racing situations through AI interaction

### UI System

- **Responsive Design**: UI should work across different screen sizes
- **Feedback**: Provide clear feedback for player actions
- **Consistency**: Maintain visual and interaction consistency
- **Accessibility**: Consider color blindness and other accessibility needs

## Version Control Guidelines

- **Descriptive Commits**: Write clear commit messages that explain changes
- **Feature Branches**: Develop new features in dedicated branches
- **Regular Commits**: Make small, frequent commits rather than large changes
- **Pull Requests**: Use PRs for code review before merging

---

Remember that the Time Riders project aims to demonstrate good software engineering practices while remaining approachable for beginners. Code should be clear, well-structured, and serve as a positive example of professional Unity development.
